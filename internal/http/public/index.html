<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Route Builder</title>
    <link rel="stylesheet" href="/leaflet-1.9.4.css"/>
    <link rel="stylesheet" href="/leaflet-routing-machine-3.2.12.css"/>
    <style>
        #map {
            overflow: hidden;
            position: absolute;
            top: 95px;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>
<body>

<span id="statusText" style="margin: 10px; text-align: center; display: block; width: 100%"></span>
<div style="text-align: center;">
    <label for="maxSpeedInput">Speed Limit for the new route, km/h</label><input id="maxSpeedInput" type="number" min="0" max="200" value="0" style="min-width: 50px; padding: 10px; width: 50px; margin: 10px; border: 1px solid #ccc; border-radius: 5px; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);">
    <button id="actionButton" style="min-width: 150px; padding: 10px 20px; background-color: rgba(53,78,225,0.87); color: white; border: none; border-radius: 5px; cursor: pointer; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);"></button>
    <button id="stopButton" style="display: none; min-width: 150px; padding: 10px 20px; background-color: rgba(217,12,88,0.87); color: white; border: none; border-radius: 5px; cursor: pointer; box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);">Stop and delete the route</button>
</div>
<div id="map"></div>

<script src="/leaflet-1.9.4.js"></script>
<script src="/leaflet-routing-machine-3.2.12.js"></script>

<script>
    const map = L.map('map').setView([47.37769, 8.54151], 13); // Default location in ZÃ¼rich
    const marker = L.marker({lat: 0, lng: 0}).addTo(map);
    let routePolyline = null;

    const eventSrc = new EventSource("/events");
    const statusText = document.getElementById("statusText");
    const actionButton = document.getElementById("actionButton");
    const stopButton = document.getElementById("stopButton");
    const maxSpeedInput = document.getElementById("maxSpeedInput");

    const textAwaitingUpdates = "Awaiting updates";
    const textPauseSimulation = "Pause simulation";
    const textRunSimulation = "Run simulation";
    actionButton.textContent = textAwaitingUpdates;

    const statusTextDefault = "You have to define route first: click on starting point and on the ending one";
    const statusTextRouteStartDefined = "Great, now click on the ending point";
    const statusTextRouteDefined = "Route defined - calculating points...";
    const statusTextPreviousRouteRunning = "Previous route is running";
    statusText.textContent = statusTextDefault;

    let waypoints = [];

    actionButton.addEventListener("click", () => {
        if (actionButton.textContent === textAwaitingUpdates) {
            return
        }
        actionButton.textContent = textAwaitingUpdates;
        fetch('/route/run', {
            method: 'GET',
        }).catch((error) => {
            console.error('Error:', error);
        });
    });

    stopButton.addEventListener("click", () => {
        fetch('/route/stop', {
            method: 'GET',
        }).then(() => {
            stopButton.style.display = "none";
            actionButton.textContent = textAwaitingUpdates;
            statusText.textContent = statusTextDefault;
            waypoints = [];
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            }
            routingControl._clearLines()
            marker.setLatLng({lat: 0, lng: 0})
        }).catch((error) => {
            console.error('Error:', error);
        });
    });

    eventSrc.onmessage = (event) => {
        const message = JSON.parse(event.data);

        if (typeof message.type === "undefined") {
            console.error("EventSource data type is undefined:", message);
            return
        }

        switch (message.type) {
            case "initial-route":
                console.log("Initial route:", message);
                // Remove previous route if exists
                if (routePolyline) {
                    map.removeLayer(routePolyline);
                }

                statusText.textContent = formatRouteName(message.name, message.distance)
                maxSpeedInput.value = message.maxSpeed || 0;

                if (message.points && message.points.length > 0) {
                    // Convert points to LatLng format
                    const routePoints = message.points.map(point =>
                        L.latLng(point.lat, point.lon)
                    );

                    // Create a layer group to hold all polylines
                    routePolyline = L.layerGroup();

                    // Create the three-layer styling that matches Leaflet Routing Machine
                    // 1. Black background
                    L.polyline(routePoints, {
                        color: 'black',
                        opacity: 0.15,
                        weight: 9,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }).addTo(routePolyline);

                    // 2. White middle layer
                    L.polyline(routePoints, {
                        color: 'white',
                        opacity: 0.8,
                        weight: 6,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }).addTo(routePolyline);

                    // 3. Red top line
                    L.polyline(routePoints, {
                        color: 'red',
                        opacity: 1,
                        weight: 2,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }).addTo(routePolyline);

                    // Add the layer group to the map
                    routePolyline.addTo(map);

                    // Fit map to the route bounds
                    map.fitBounds(L.polyline(routePoints).getBounds());

                    // Move marker to first point
                    if (routePoints.length > 0) {
                        marker.setLatLng(routePoints[0]);
                    }
                }
                break;

            case "current-point":
                marker.setLatLng({lat: message.lat, lng: message.lon});
                if (message.status === "Running") {
                    actionButton.textContent = textPauseSimulation;
                    if (statusText.textContent === statusTextDefault) {
                        statusText.textContent = statusTextPreviousRouteRunning;
                    }
                    if (stopButton.style.display === "none") {
                        stopButton.style.display = "inline-block";
                    }
                } else if (message.status === "Paused") {
                    actionButton.textContent = textRunSimulation;
                }
                break;
            default:
                console.error("Unknown event type:", message.type);
                break;
        }
    };

    eventSrc.onerror = (event) => {
        console.error("EventSource failed:", event);
    };

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const routingControl = L.Routing.control({
        waypoints: [],
        routeWhileDragging: false,
        show: false,
        addWaypoints: false,
        createMarker: () => null, // no default markers
    }).addTo(map);

    let routeDefined = false;
    map.on('click', function (e) {
        if (waypoints.length < 2) {
            waypoints.push(e.latlng);
            if (waypoints.length === 2) {
                routingControl.setWaypoints(waypoints);
            }
        }

        if (waypoints.length === 1) {
            statusText.textContent = statusTextRouteStartDefined;
        } else if (waypoints.length === 2 && !routeDefined) {
            statusText.textContent = statusTextRouteDefined;
            routeDefined = true;
        }

    });

    routingControl.on('routesfound', function (e) {
        statusText.textContent = formatRouteName(e.routes[0].name, e.routes[0].summary.totalDistance)

        fetch('/route', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                name: e.routes[0].name,
                distance: e.routes[0].summary.totalDistance,
                maxSpeed: parseInt(maxSpeedInput.value) || 0,
                coordinates: e.routes[0].coordinates,
            }),
        }).catch((error) => {
            console.error('Error:', error);
        });
    });

    function formatRouteName(name, distance) {
        let distanceString;
        if (distance > 10000) {
            distanceString = (distance / 1000).toFixed(2) + 'km';
        } else {
            distanceString = distance.toFixed(2) + 'm';
        }
        let result = `Total distance: ${distanceString}`;
        if (name !== "") {
            result = `${name}. ${result}`;
        }
        return result;
    }
</script>
</body>
</html>
